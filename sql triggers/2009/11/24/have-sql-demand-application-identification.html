<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Have SQL Demand Application Identification | Your awesome title</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Have SQL Demand Application Identification" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="How many times have you run Profiler on your SQL Servers to see this? With all of those apps identifying themselves as .Net SqlClient Data Provider, how can you tell which app is really making those queries? Unless each app uses a distinct login, you would never know. And many times devs will reuse logins for their own ease. I ran into this problem while I was doing some migration planning. I was profiling the server to see what apps were making queries to a specific database we were migrating over to another server. I wanted to make sure that anything making a connection was properly configured after the move. I found something similar to the shot above; connections from different machines making different queries at different, albeit regular intervals, all identified as &quot;.Net SqlClient Data Provider.&quot; With some other detective work, I was able to figure out where they were coming from. How can this be avoided? When developers are setting up their connection strings, they need to specify the Application Name parameter. An example is below. Using LOGON TRIGGERS in SQL 2008 and up, you can go one step further and start auditing logons and watching for any connection made that uses a generic Application Name. There is a limited amount of information available in the EVENTDATA() from a LOGON EVENT. You can get more information about the connection by joining to the sys.dm_exec_sessions DMV. ... DECLARE @data XML, @ApplicationName NVARCHAR(128) SET @data = EVENTDATA() SELECT @ApplicationName = [program_name] FROM sys.dm_exec_sessions WHERE session_id = @data.value(&#39;(/EVENT_INSTANCE/SPID)[1]&#39;, &#39;int&#39;) ... In the code above, I first declare an XML variable to hold the data that comes from the EVENTDATA() function. Then use the SPID to join to the sys.dm_exec_sessions DMV to get the program_name, which becomes our Application Name. From this, you can log information about the connection. You can start researching anything that doesn&#39;t have a specific application name and start encouraging your developers to include that portion of the connection string. You can go even further and block any generic connections. Using the trigger below, any connection that comes in under &quot;.Net SqlClient Data Provider&quot; gets disconnected via ROLLBACK. You can add to or alter the IN clause to prevent generic Java, PHP, etc. connections. You can check for blanks, or even prevent certain apps from logging in all together, regardless of credentials. USE [master]; GO" />
<meta property="og:description" content="How many times have you run Profiler on your SQL Servers to see this? With all of those apps identifying themselves as .Net SqlClient Data Provider, how can you tell which app is really making those queries? Unless each app uses a distinct login, you would never know. And many times devs will reuse logins for their own ease. I ran into this problem while I was doing some migration planning. I was profiling the server to see what apps were making queries to a specific database we were migrating over to another server. I wanted to make sure that anything making a connection was properly configured after the move. I found something similar to the shot above; connections from different machines making different queries at different, albeit regular intervals, all identified as &quot;.Net SqlClient Data Provider.&quot; With some other detective work, I was able to figure out where they were coming from. How can this be avoided? When developers are setting up their connection strings, they need to specify the Application Name parameter. An example is below. Using LOGON TRIGGERS in SQL 2008 and up, you can go one step further and start auditing logons and watching for any connection made that uses a generic Application Name. There is a limited amount of information available in the EVENTDATA() from a LOGON EVENT. You can get more information about the connection by joining to the sys.dm_exec_sessions DMV. ... DECLARE @data XML, @ApplicationName NVARCHAR(128) SET @data = EVENTDATA() SELECT @ApplicationName = [program_name] FROM sys.dm_exec_sessions WHERE session_id = @data.value(&#39;(/EVENT_INSTANCE/SPID)[1]&#39;, &#39;int&#39;) ... In the code above, I first declare an XML variable to hold the data that comes from the EVENTDATA() function. Then use the SPID to join to the sys.dm_exec_sessions DMV to get the program_name, which becomes our Application Name. From this, you can log information about the connection. You can start researching anything that doesn&#39;t have a specific application name and start encouraging your developers to include that portion of the connection string. You can go even further and block any generic connections. Using the trigger below, any connection that comes in under &quot;.Net SqlClient Data Provider&quot; gets disconnected via ROLLBACK. You can add to or alter the IN clause to prevent generic Java, PHP, etc. connections. You can check for blanks, or even prevent certain apps from logging in all together, regardless of credentials. USE [master]; GO" />
<link rel="canonical" href="/sql%20triggers/2009/11/24/have-sql-demand-application-identification.html" />
<meta property="og:url" content="/sql%20triggers/2009/11/24/have-sql-demand-application-identification.html" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2009-11-24T08:27:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Have SQL Demand Application Identification" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/sql%20triggers/2009/11/24/have-sql-demand-application-identification.html","headline":"Have SQL Demand Application Identification","dateModified":"2009-11-24T08:27:00-06:00","datePublished":"2009-11-24T08:27:00-06:00","mainEntityOfPage":{"@type":"WebPage","@id":"/sql%20triggers/2009/11/24/have-sql-demand-application-identification.html"},"description":"How many times have you run Profiler on your SQL Servers to see this? With all of those apps identifying themselves as .Net SqlClient Data Provider, how can you tell which app is really making those queries? Unless each app uses a distinct login, you would never know. And many times devs will reuse logins for their own ease. I ran into this problem while I was doing some migration planning. I was profiling the server to see what apps were making queries to a specific database we were migrating over to another server. I wanted to make sure that anything making a connection was properly configured after the move. I found something similar to the shot above; connections from different machines making different queries at different, albeit regular intervals, all identified as &quot;.Net SqlClient Data Provider.&quot; With some other detective work, I was able to figure out where they were coming from. How can this be avoided? When developers are setting up their connection strings, they need to specify the Application Name parameter. An example is below. Using LOGON TRIGGERS in SQL 2008 and up, you can go one step further and start auditing logons and watching for any connection made that uses a generic Application Name. There is a limited amount of information available in the EVENTDATA() from a LOGON EVENT. You can get more information about the connection by joining to the sys.dm_exec_sessions DMV. ... DECLARE @data XML, @ApplicationName NVARCHAR(128) SET @data = EVENTDATA() SELECT @ApplicationName = [program_name] FROM sys.dm_exec_sessions WHERE session_id = @data.value(&#39;(/EVENT_INSTANCE/SPID)[1]&#39;, &#39;int&#39;) ... In the code above, I first declare an XML variable to hold the data that comes from the EVENTDATA() function. Then use the SPID to join to the sys.dm_exec_sessions DMV to get the program_name, which becomes our Application Name. From this, you can log information about the connection. You can start researching anything that doesn&#39;t have a specific application name and start encouraging your developers to include that portion of the connection string. You can go even further and block any generic connections. Using the trigger below, any connection that comes in under &quot;.Net SqlClient Data Provider&quot; gets disconnected via ROLLBACK. You can add to or alter the IN clause to prevent generic Java, PHP, etc. connections. You can check for blanks, or even prevent certain apps from logging in all together, regardless of credentials. USE [master]; GO","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/about/">About</a><a class="page-link" href="/contact-me/">Contact Me</a><a class="page-link" href="/privacy-policy/">Privacy Policy</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Have SQL Demand Application Identification</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2009-11-24T08:27:00-06:00" itemprop="datePublished">Nov 24, 2009
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"lotsahelp", "login"=>"lotsahelp", "email"=>"eric@erichumphrey.com", "url"=>""}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>How many times have you run Profiler on your SQL Servers to see this?</p>
<p><a style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;" href="http://2.bp.blogspot.com/_OEOq9aEto20/SwvqsplCArI/AAAAAAAADDI/09TjlPbCays/s1600/Profiler+pic+cropped.png"><img src="http://2.bp.blogspot.com/_OEOq9aEto20/SwvqsplCArI/AAAAAAAADDI/09TjlPbCays/s400/Profiler+pic+cropped.png" border="0" alt="" /></a></p>
<p>With all of those apps identifying themselves as .Net SqlClient Data Provider, how can you tell which app is really making those queries?  Unless each app uses a distinct login, you would never know. And many times devs will reuse logins for their own ease.</p>
<p>I ran into this problem while I was doing some migration planning. I was profiling the server to see what apps were making queries to a specific database we were migrating over to another server. I wanted to make sure that anything making a connection was properly configured after the move. I found something similar to the shot above; connections from different machines making different queries at different, albeit regular intervals, all identified as ".Net SqlClient Data Provider." With some other detective work, I was able to figure out where they were coming from.</p>
<p>How can this be avoided? When developers are setting up their connection strings, they need to specify the Application Name parameter. An example is below.</p>
<pre lang="xml">
<add name="LOCAL" connectionString="Data Source=(local);Initial Catalog=master;Integrated Security=True;Application Name=LoginTriggerDemoApp" /></pre>
<p>Using <a href="http://msdn.microsoft.com/en-us/library/bb326598.aspx">LOGON TRIGGERS</a> in SQL 2008 and up, you can go one step further and start auditing logons and watching for any connection made that uses a generic Application Name. There is a limited amount of information available in the <a href="http://msdn.microsoft.com/en-us/library/ms173781.aspx">EVENTDATA()</a> from a LOGON EVENT.  You can get more information about the connection by joining to the <a href="http://msdn.microsoft.com/en-us/library/ms176013.aspx">sys.dm_exec_sessions</a> DMV.</p>
<pre lang="tsql">
...
DECLARE @data XML, @ApplicationName NVARCHAR(128)
SET @data = EVENTDATA()
SELECT @ApplicationName = [program_name]
FROM sys.dm_exec_sessions
WHERE session_id = @data.value('(/EVENT_INSTANCE/SPID)[1]', 'int')
...
</pre>
<p>In the code above, I first declare an XML variable to hold the data that comes from the EVENTDATA() function. Then use the SPID to join to the sys.dm_exec_sessions DMV to get the program_name, which becomes our Application Name. From this, you can log information about the connection. You can start researching anything that doesn't have a specific application name and start encouraging your developers to include that portion of the connection string.</p>
<p>You can go even further and block any generic connections. Using the trigger below, any connection that comes in under "<em>.Net SqlClient Data Provider</em>" gets disconnected via ROLLBACK. You can add to or alter the IN clause to prevent generic Java, PHP, etc. connections. You can check for blanks, or even prevent certain apps from logging in all together, regardless of credentials.</p>
<pre lang="tsql">
USE [master];
GO


/****** Object: DdlTrigger [Deny_Generic_ConnString_Trigger] ******/
IF EXISTS(
	SELECT * FROM master.sys.server_triggers
	WHERE parent_class_desc = 'SERVER'
		AND name = N'Deny_Generic_ConnString_Trigger')
DROP TRIGGER [Deny_Generic_ConnString_Trigger] ON ALL SERVER
GO

CREATE TRIGGER Deny_Generic_ConnString_Trigger
ON ALL SERVER
FOR LOGON
AS
BEGIN
DECLARE @AppName nvarchar(128)
SELECT @AppName = [program_name]
FROM sys.dm_exec_sessions
WHERE session_id = EVENTDATA().value(
    '(/EVENT_INSTANCE/SPID)[1]', 'int')


IF @AppName IN ('.Net SqlClient Data Provider')
    ROLLBACK; --Disconnect the session

END;
</pre>
<h2>Notes for Deployment</h2>
<p>If you have dev &amp; QA servers, test these out there first. Give your application developers time to make changes and test against these new triggers. Also, you may not be able to change 3<sup>rd</sup> party apps, so you can make exceptions based on host names or anything else available in the EVENTDATA() or sys.dm_exec_sessions. I did find out that Reporting Services does not like either of these triggers in place. Even the logging trigger will prevent the Report Manager from running.</p>
<p>Blocking generic applications may have consequences on a server that is already serving data to unidentified apps, so be careful. You may want to put logging in for a time and track down any offending applications and give them time to change. For a server coming online though, blocking generic apps may be a good way of preventing a lot of unnecessary detective work, and make profiling or migrating your servers easier.</p>
<p>I have included my scripts as well as sample C# project to demonstrate the technique. <a href="http://sites.google.com/site/erichumphrey/LoginTriggers.zip">Download now</a>.</p>
<p>A special thanks to <a href="http://www.brentozar.com/">Brent Ozar</a> for giving me his opinion on this post and inflating my head somewhat.</p>

  </div><a class="u-url" href="/sql%20triggers/2009/11/24/have-sql-demand-application-identification.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
