<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>NOLOCK for Developers | Your awesome title</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="NOLOCK for Developers" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="What is NOLOCK? NOLOCK is a table hint for SQL Server that tells the engine to not take locks and ignore any locks when querying that table. This is equivalent to the READUNCOMMITTED table hint. From MSDN: Specifies that dirty reads are allowed. No shared locks are issued to prevent other transactions from modifying data read by the current transaction, and exclusive locks set by other transactions do not block the current transaction from reading the locked data. Allowing dirty reads can cause higher concurrency, but at the cost of reading data modifications that then are rolled back by other transactions. This may generate errors for your transaction, present users with data that was never committed, or cause users to see records twice (or not at all). For more information about dirty reads, nonrepeatable reads, and phantom reads, see&nbsp;Concurrency Effects. So you might be thinking that this NOLOCK thing is great and will solve all your performance problems... There&#39;s a Trade-off... What&#39;s the cost of using the NOLOCK hint or setting the Isolation Level to READ UNCOMMITTED everywhere? Well, you cannot guarantee the accuracy of your queries anymore. If the queries can read data in flight, you might read data that never gets committed. You might read data twice. You might read data that&#39;s in the process of being updated or deleted. There&#39;s a lot of mights in there. You need to ask yourself and the person that depends on this query, do they value accuracy or speed. NOLOCK is a Last Resort Many of the problems cause by locking and blocking, which NOLOCK gets around, can be solved by basic performance tuning. Limiting the data you are working with by using appropriate WHERE clauses is a good first step. SQL Server by default tries to lock data at the row level and only&nbsp;escalates&nbsp;to the table level if it determines it would be cheaper to do so. It might escalate quicker than you think though. If &nbsp;two queries are operating on different rows in the same table, they will not block each other unless escalation has occurred. Note that I mention rows, not columns. If two queries are making changes to different columns in the same row, one will block the other until done. Adding appropriate indexes or modifying existing indexes would be a second step. These can speed up readers which let writers in quicker. Another alternative to using NOLOCK is to use some level of row versioning within SQL Server such as&nbsp;READ_COMMITTED_SNAPSHOT and / or ALLOW_SNAPSHOT_ISOLATION. This allows more concurrency at the cost of increased tempdb usage. It does this by storing old version(s) of a row in tempdb until it is no longer needed. If you&#39;re doing a quick read with no other connection trying to alter that data, then the lifespan in tempdb is very short. If more concurrent operations happen on that row, the lifespan can grow. Before implementing either of these levels, be sure to have a good understanding of the trade-offs of row versioning as it might cause more problems that it solves. The NOLOCK Resort Earlier I said to use NOLOCK as a last resort... in transactional workloads. NOLOCK might&nbsp;make a good fit for when you&#39;re reporting out of your transactional database. Reporting is better done from a reporting copy of the data. Sometimes we don&#39;t have that luxury and reporting must be done against the live data. In most cases, we want the transactional workload to take priority over the reports. Telling our reports not to take locks allows the transactions to continue unhindered by locks, though they still might be fighting for CPU and I/O resources. The same rules apply about speed vs accuracy, but usually reports don&#39;t have to be to the second or penny accurate. In this case, NOLOCK may make sense. Just make sure your report consumers are aware that there might be a margin of error. Further Reading: Kendra Little (blog | twitter) made up a poster that helps visualize the different isolation levels. She also put together a great list of links about NOLOCK and the other isolation levels. Paul Randal (blog | twitter) has some great content on locking. He also does a good job of explaining locking &amp; blocking in this video. Kimberly Tripp (blog | twitter) has more info about indexing." />
<meta property="og:description" content="What is NOLOCK? NOLOCK is a table hint for SQL Server that tells the engine to not take locks and ignore any locks when querying that table. This is equivalent to the READUNCOMMITTED table hint. From MSDN: Specifies that dirty reads are allowed. No shared locks are issued to prevent other transactions from modifying data read by the current transaction, and exclusive locks set by other transactions do not block the current transaction from reading the locked data. Allowing dirty reads can cause higher concurrency, but at the cost of reading data modifications that then are rolled back by other transactions. This may generate errors for your transaction, present users with data that was never committed, or cause users to see records twice (or not at all). For more information about dirty reads, nonrepeatable reads, and phantom reads, see&nbsp;Concurrency Effects. So you might be thinking that this NOLOCK thing is great and will solve all your performance problems... There&#39;s a Trade-off... What&#39;s the cost of using the NOLOCK hint or setting the Isolation Level to READ UNCOMMITTED everywhere? Well, you cannot guarantee the accuracy of your queries anymore. If the queries can read data in flight, you might read data that never gets committed. You might read data twice. You might read data that&#39;s in the process of being updated or deleted. There&#39;s a lot of mights in there. You need to ask yourself and the person that depends on this query, do they value accuracy or speed. NOLOCK is a Last Resort Many of the problems cause by locking and blocking, which NOLOCK gets around, can be solved by basic performance tuning. Limiting the data you are working with by using appropriate WHERE clauses is a good first step. SQL Server by default tries to lock data at the row level and only&nbsp;escalates&nbsp;to the table level if it determines it would be cheaper to do so. It might escalate quicker than you think though. If &nbsp;two queries are operating on different rows in the same table, they will not block each other unless escalation has occurred. Note that I mention rows, not columns. If two queries are making changes to different columns in the same row, one will block the other until done. Adding appropriate indexes or modifying existing indexes would be a second step. These can speed up readers which let writers in quicker. Another alternative to using NOLOCK is to use some level of row versioning within SQL Server such as&nbsp;READ_COMMITTED_SNAPSHOT and / or ALLOW_SNAPSHOT_ISOLATION. This allows more concurrency at the cost of increased tempdb usage. It does this by storing old version(s) of a row in tempdb until it is no longer needed. If you&#39;re doing a quick read with no other connection trying to alter that data, then the lifespan in tempdb is very short. If more concurrent operations happen on that row, the lifespan can grow. Before implementing either of these levels, be sure to have a good understanding of the trade-offs of row versioning as it might cause more problems that it solves. The NOLOCK Resort Earlier I said to use NOLOCK as a last resort... in transactional workloads. NOLOCK might&nbsp;make a good fit for when you&#39;re reporting out of your transactional database. Reporting is better done from a reporting copy of the data. Sometimes we don&#39;t have that luxury and reporting must be done against the live data. In most cases, we want the transactional workload to take priority over the reports. Telling our reports not to take locks allows the transactions to continue unhindered by locks, though they still might be fighting for CPU and I/O resources. The same rules apply about speed vs accuracy, but usually reports don&#39;t have to be to the second or penny accurate. In this case, NOLOCK may make sense. Just make sure your report consumers are aware that there might be a margin of error. Further Reading: Kendra Little (blog | twitter) made up a poster that helps visualize the different isolation levels. She also put together a great list of links about NOLOCK and the other isolation levels. Paul Randal (blog | twitter) has some great content on locking. He also does a good job of explaining locking &amp; blocking in this video. Kimberly Tripp (blog | twitter) has more info about indexing." />
<link rel="canonical" href="/dba/development/sql/sqlserverpedia%20syndication/2011/03/25/nolock-for-developers.html" />
<meta property="og:url" content="/dba/development/sql/sqlserverpedia%20syndication/2011/03/25/nolock-for-developers.html" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2011-03-25T07:20:47-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="NOLOCK for Developers" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/dba/development/sql/sqlserverpedia%20syndication/2011/03/25/nolock-for-developers.html","headline":"NOLOCK for Developers","dateModified":"2011-03-25T07:20:47-05:00","datePublished":"2011-03-25T07:20:47-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"/dba/development/sql/sqlserverpedia%20syndication/2011/03/25/nolock-for-developers.html"},"description":"What is NOLOCK? NOLOCK is a table hint for SQL Server that tells the engine to not take locks and ignore any locks when querying that table. This is equivalent to the READUNCOMMITTED table hint. From MSDN: Specifies that dirty reads are allowed. No shared locks are issued to prevent other transactions from modifying data read by the current transaction, and exclusive locks set by other transactions do not block the current transaction from reading the locked data. Allowing dirty reads can cause higher concurrency, but at the cost of reading data modifications that then are rolled back by other transactions. This may generate errors for your transaction, present users with data that was never committed, or cause users to see records twice (or not at all). For more information about dirty reads, nonrepeatable reads, and phantom reads, see&nbsp;Concurrency Effects. So you might be thinking that this NOLOCK thing is great and will solve all your performance problems... There&#39;s a Trade-off... What&#39;s the cost of using the NOLOCK hint or setting the Isolation Level to READ UNCOMMITTED everywhere? Well, you cannot guarantee the accuracy of your queries anymore. If the queries can read data in flight, you might read data that never gets committed. You might read data twice. You might read data that&#39;s in the process of being updated or deleted. There&#39;s a lot of mights in there. You need to ask yourself and the person that depends on this query, do they value accuracy or speed. NOLOCK is a Last Resort Many of the problems cause by locking and blocking, which NOLOCK gets around, can be solved by basic performance tuning. Limiting the data you are working with by using appropriate WHERE clauses is a good first step. SQL Server by default tries to lock data at the row level and only&nbsp;escalates&nbsp;to the table level if it determines it would be cheaper to do so. It might escalate quicker than you think though. If &nbsp;two queries are operating on different rows in the same table, they will not block each other unless escalation has occurred. Note that I mention rows, not columns. If two queries are making changes to different columns in the same row, one will block the other until done. Adding appropriate indexes or modifying existing indexes would be a second step. These can speed up readers which let writers in quicker. Another alternative to using NOLOCK is to use some level of row versioning within SQL Server such as&nbsp;READ_COMMITTED_SNAPSHOT and / or ALLOW_SNAPSHOT_ISOLATION. This allows more concurrency at the cost of increased tempdb usage. It does this by storing old version(s) of a row in tempdb until it is no longer needed. If you&#39;re doing a quick read with no other connection trying to alter that data, then the lifespan in tempdb is very short. If more concurrent operations happen on that row, the lifespan can grow. Before implementing either of these levels, be sure to have a good understanding of the trade-offs of row versioning as it might cause more problems that it solves. The NOLOCK Resort Earlier I said to use NOLOCK as a last resort... in transactional workloads. NOLOCK might&nbsp;make a good fit for when you&#39;re reporting out of your transactional database. Reporting is better done from a reporting copy of the data. Sometimes we don&#39;t have that luxury and reporting must be done against the live data. In most cases, we want the transactional workload to take priority over the reports. Telling our reports not to take locks allows the transactions to continue unhindered by locks, though they still might be fighting for CPU and I/O resources. The same rules apply about speed vs accuracy, but usually reports don&#39;t have to be to the second or penny accurate. In this case, NOLOCK may make sense. Just make sure your report consumers are aware that there might be a margin of error. Further Reading: Kendra Little (blog | twitter) made up a poster that helps visualize the different isolation levels. She also put together a great list of links about NOLOCK and the other isolation levels. Paul Randal (blog | twitter) has some great content on locking. He also does a good job of explaining locking &amp; blocking in this video. Kimberly Tripp (blog | twitter) has more info about indexing.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/about/">About</a><a class="page-link" href="/contact-me/">Contact Me</a><a class="page-link" href="/privacy-policy/">Privacy Policy</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">NOLOCK for Developers</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2011-03-25T07:20:47-05:00" itemprop="datePublished">Mar 25, 2011
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"lotsahelp", "login"=>"lotsahelp", "email"=>"eric@erichumphrey.com", "url"=>""}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><span style="font-size: 20px; font-weight: bold;">What is NOLOCK?</span></p>
<p>NOLOCK is a table hint for SQL Server that tells the engine to not take locks and ignore any locks when querying that table. This is equivalent to the READUNCOMMITTED table hint.</p>
<p>From <a href="http://msdn.microsoft.com/en-us/library/ms187373.aspx">MSDN</a>:</p>
<blockquote><p>Specifies that dirty reads are allowed. No shared locks are issued to prevent other transactions from modifying data read by the current transaction, and exclusive locks set by other transactions do not block the current transaction from reading the locked data. Allowing dirty reads can cause higher concurrency, but at the cost of reading data modifications that then are rolled back by other transactions. This may generate errors for your transaction, present users with data that was never committed, or cause users to see records twice (or not at all). For more information about dirty reads, nonrepeatable reads, and phantom reads, see&nbsp;<a href="http://msdn.microsoft.com/en-us/library/ms190805.aspx">Concurrency Effects</a>.</p></blockquote>
<p>So you might be thinking that this NOLOCK thing is great and will solve all your performance problems...</p>
<h2>There's a Trade-off...</h2>
<p>What's the cost of using the NOLOCK hint or setting the Isolation Level to READ UNCOMMITTED everywhere? Well, you cannot guarantee the accuracy of your queries anymore. If the queries can read data in flight, you might read data that never gets committed. You might read data twice. You might read data that's in the process of being updated or deleted. There's a lot of mights in there. You need to ask yourself and the person that depends on this query, do they value accuracy or speed.</p>
<h2>NOLOCK is a Last Resort</h2>
<p>Many of the problems cause by locking and blocking, which NOLOCK gets around, can be solved by basic performance tuning. Limiting the data you are working with by using appropriate WHERE clauses is a good first step. SQL Server by default tries to lock data at the row level and only&nbsp;escalates&nbsp;to the table level if it determines it would be cheaper to do so. It might escalate <a href="http://sqlskills.com/BLOGS/KIMBERLY/category/The-Tipping-Point.aspx">quicker than you think</a> though. If &nbsp;two queries are operating on different rows in the same table, they will not block each other unless escalation has occurred. Note that I mention rows, not columns. If two queries are making changes to different columns in the same row, one will block the other until done. Adding appropriate indexes or modifying existing indexes would be a second step. These can speed up readers which let writers in quicker.</p>
<p>Another alternative to using NOLOCK is to use some <a href="http://msdn.microsoft.com/en-us/library/cc917674.aspx">level of row versioning</a> within SQL Server such as&nbsp;READ_COMMITTED_SNAPSHOT and / or ALLOW_SNAPSHOT_ISOLATION. This allows more concurrency at the cost of increased tempdb usage. It does this by storing old version(s) of a row in tempdb until it is no longer needed. If you're doing a quick read with no other connection trying to alter that data, then the lifespan in tempdb is very short. If more concurrent operations happen on that row, the lifespan can grow. Before implementing either of these levels, be sure to have a good understanding of the <a href="http://technet.microsoft.com/en-us/library/ms177404.aspx">trade-offs of row versioning</a> as it might cause more problems that it solves.</p>
<h2>The NOLOCK Resort</h2>
<p>Earlier I said to use NOLOCK as a last resort... in transactional workloads. NOLOCK might&nbsp;make a good fit for when you're reporting out of your transactional database. Reporting is better done from a reporting copy of the data. Sometimes we don't have that luxury and reporting must be done against the live data. In most cases, we want the transactional workload to take priority over the reports. Telling our reports not to take locks allows the transactions to continue unhindered by locks, though they still might be fighting for CPU and I/O resources. The same rules apply about speed vs accuracy, but usually reports don't have to be to the second or penny accurate. In this case, NOLOCK may make sense. Just make sure your report consumers are aware that there might be a margin of error.</p>
<h2>Further Reading:</h2>
<p>Kendra Little (<a href="http://littlekendra.com">blog</a> | <a href="http://twitter.com/#!/Kendra_Little">twitter</a>) <a href="http://www.littlekendra.com/2011/02/08/isoposter/">made up a poster</a> that helps visualize the different isolation levels. She also put together a great <a href="http://www.littlekendra.com/resources/isolation/">list of links</a> about NOLOCK and the other isolation levels.</p>
<p>Paul Randal (<a href="http://www.sqlskills.com/blogs/paul">blog</a> | <a href="http://twitter.com/#!/PaulRandal">twitter</a>) has some great <a href="http://www.sqlskills.com/BLOGS/PAUL/category/Locking.aspx">content on locking</a>. He also does a good job of explaining locking &amp; blocking in <a href="http://technet.microsoft.com/en-us/sqlserver/gg508892.aspx">this video</a>.</p>
<p>Kimberly Tripp (<a href="http://www.sqlskills.com/blogs/Kimberly/">blog</a> | <a href="http://twitter.com/#!/KimberlyLTripp">twitter</a>) has more info <a href="http://www.sqlskills.com/BLOGS/KIMBERLY/category/Indexes.aspx">about indexing</a>.</p>

  </div><a class="u-url" href="/dba/development/sql/sqlserverpedia%20syndication/2011/03/25/nolock-for-developers.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
