<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Using .NET’s TryParse() in SQL CLR | Your awesome title</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Using .NET’s TryParse() in SQL CLR" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In my current position, I deal with a lot of data quality issues. This column should be a date, but we get an integer, string, NULLs, etc. As a rule of our processing, if we cannot convert the value to the appropriate data type, then we use a default value, or choice of values depending on the situation. SQL Server already has the CAST and CONVERT functions built in. There is a shortcoming of these functions though. If the value cannot be converted, you get an error and your processing stops. For converting values, you have to pass through the table twice. Once to manually convert any known values that cannot convert into something that can or set them to NULL. Then you can run CAST or CONVERT on the values. We wanted to be able to do this in one step and this led us to .NET&#39;s TryParse() method. Each basic data type in .NET has a TryParse() method that attempts to parse the value and returns a boolean if successful. The parsed value is passed back through an output variable. In my case, I don&#39;t really care about the boolean return value. I want a value if it was successful, otherwise give me a NULL. This is the syntax for creating the SQL CLR version. And the syntax for using it within SQL. Why would I want NULL on failure you might ask. Well, if I get a NULL back, then I can easily check against NULL for success and use functions such as COALESCE to&nbsp;substitute&nbsp;a default value if the parsing failed. A good case for us to use this is when we have blank strings that need to convert into a default date. CONVERT cannot cast the value &#39;&#39; to a datetime and thus throws an error. Now I can do things like the following to allow processing to complete if CONVERT hits a bad value. Now the drawbacks of using this method. If you need to make sure you have all valid values beforehand, this will cause those to fail silently. An alternative would be to use this to check for invalid values. You can do something like this to find problematic values: This allows you to find all&nbsp;unconvertible&nbsp;values without SQL throwing an error as it would if you had tested with CONVERT(). We mainly use this function in the second situation. We want to know all values that would cause problems. I have also made versions for Int, BigInt and Money following the same basic pattern. As with any CLR functions, make sure you know the security and performance&nbsp;implications&nbsp;when using it. Hopefully if you do a lot of data staging then converting this could make your life easier." />
<meta property="og:description" content="In my current position, I deal with a lot of data quality issues. This column should be a date, but we get an integer, string, NULLs, etc. As a rule of our processing, if we cannot convert the value to the appropriate data type, then we use a default value, or choice of values depending on the situation. SQL Server already has the CAST and CONVERT functions built in. There is a shortcoming of these functions though. If the value cannot be converted, you get an error and your processing stops. For converting values, you have to pass through the table twice. Once to manually convert any known values that cannot convert into something that can or set them to NULL. Then you can run CAST or CONVERT on the values. We wanted to be able to do this in one step and this led us to .NET&#39;s TryParse() method. Each basic data type in .NET has a TryParse() method that attempts to parse the value and returns a boolean if successful. The parsed value is passed back through an output variable. In my case, I don&#39;t really care about the boolean return value. I want a value if it was successful, otherwise give me a NULL. This is the syntax for creating the SQL CLR version. And the syntax for using it within SQL. Why would I want NULL on failure you might ask. Well, if I get a NULL back, then I can easily check against NULL for success and use functions such as COALESCE to&nbsp;substitute&nbsp;a default value if the parsing failed. A good case for us to use this is when we have blank strings that need to convert into a default date. CONVERT cannot cast the value &#39;&#39; to a datetime and thus throws an error. Now I can do things like the following to allow processing to complete if CONVERT hits a bad value. Now the drawbacks of using this method. If you need to make sure you have all valid values beforehand, this will cause those to fail silently. An alternative would be to use this to check for invalid values. You can do something like this to find problematic values: This allows you to find all&nbsp;unconvertible&nbsp;values without SQL throwing an error as it would if you had tested with CONVERT(). We mainly use this function in the second situation. We want to know all values that would cause problems. I have also made versions for Int, BigInt and Money following the same basic pattern. As with any CLR functions, make sure you know the security and performance&nbsp;implications&nbsp;when using it. Hopefully if you do a lot of data staging then converting this could make your life easier." />
<link rel="canonical" href="/.net/c%23/clr/sql/2010/06/26/using-nets-tryparse-in-sql-clr.html" />
<meta property="og:url" content="/.net/c%23/clr/sql/2010/06/26/using-nets-tryparse-in-sql-clr.html" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2010-06-26T11:53:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Using .NET’s TryParse() in SQL CLR" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/.net/c%23/clr/sql/2010/06/26/using-nets-tryparse-in-sql-clr.html","headline":"Using .NET’s TryParse() in SQL CLR","dateModified":"2010-06-26T11:53:00-05:00","datePublished":"2010-06-26T11:53:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"/.net/c%23/clr/sql/2010/06/26/using-nets-tryparse-in-sql-clr.html"},"description":"In my current position, I deal with a lot of data quality issues. This column should be a date, but we get an integer, string, NULLs, etc. As a rule of our processing, if we cannot convert the value to the appropriate data type, then we use a default value, or choice of values depending on the situation. SQL Server already has the CAST and CONVERT functions built in. There is a shortcoming of these functions though. If the value cannot be converted, you get an error and your processing stops. For converting values, you have to pass through the table twice. Once to manually convert any known values that cannot convert into something that can or set them to NULL. Then you can run CAST or CONVERT on the values. We wanted to be able to do this in one step and this led us to .NET&#39;s TryParse() method. Each basic data type in .NET has a TryParse() method that attempts to parse the value and returns a boolean if successful. The parsed value is passed back through an output variable. In my case, I don&#39;t really care about the boolean return value. I want a value if it was successful, otherwise give me a NULL. This is the syntax for creating the SQL CLR version. And the syntax for using it within SQL. Why would I want NULL on failure you might ask. Well, if I get a NULL back, then I can easily check against NULL for success and use functions such as COALESCE to&nbsp;substitute&nbsp;a default value if the parsing failed. A good case for us to use this is when we have blank strings that need to convert into a default date. CONVERT cannot cast the value &#39;&#39; to a datetime and thus throws an error. Now I can do things like the following to allow processing to complete if CONVERT hits a bad value. Now the drawbacks of using this method. If you need to make sure you have all valid values beforehand, this will cause those to fail silently. An alternative would be to use this to check for invalid values. You can do something like this to find problematic values: This allows you to find all&nbsp;unconvertible&nbsp;values without SQL throwing an error as it would if you had tested with CONVERT(). We mainly use this function in the second situation. We want to know all values that would cause problems. I have also made versions for Int, BigInt and Money following the same basic pattern. As with any CLR functions, make sure you know the security and performance&nbsp;implications&nbsp;when using it. Hopefully if you do a lot of data staging then converting this could make your life easier.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/about/">About</a><a class="page-link" href="/contact-me/">Contact Me</a><a class="page-link" href="/privacy-policy/">Privacy Policy</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Using .NET&#39;s TryParse() in SQL CLR</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2010-06-26T11:53:00-05:00" itemprop="datePublished">Jun 26, 2010
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"display_name"=>"lotsahelp", "login"=>"lotsahelp", "email"=>"eric@erichumphrey.com", "url"=>""}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In my current position, I deal with a lot of data quality issues. This column should be a date, but we get an integer, string, NULLs, etc. As a rule of our processing, if we cannot convert the value to the appropriate data type, then we use a default value, or choice of values depending on the situation.</p>
<p>SQL Server already has the CAST and CONVERT functions built in. There is a shortcoming of these functions though. If the value cannot be converted, you get an error and your processing stops. For converting values, you have to pass through the table twice. Once to manually convert any known values that cannot convert into something that can or set them to NULL. Then you can run CAST or CONVERT on the values. We wanted to be able to do this in one step and this led us to .NET's TryParse() method.</p>
<p>Each basic data type in .NET has a TryParse() method that attempts to parse the value and returns a boolean if successful. The parsed value is passed back through an output variable. In my case, I don't really care about the boolean return value. I want a value if it was successful, otherwise give me a NULL. This is the syntax for creating the SQL CLR version.
<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_OEOq9aEto20/TCYzZWwVwDI/AAAAAAAAEuw/uTblcEvNgds/s1600/cs_ParseDateTime.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="130" src="http://3.bp.blogspot.com/_OEOq9aEto20/TCYzZWwVwDI/AAAAAAAAEuw/uTblcEvNgds/s400/cs_ParseDateTime.png" width="400" /></a></div>
<p>And the syntax for using it within SQL.
<div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_OEOq9aEto20/TCY1T2420dI/AAAAAAAAEu4/5fs7s-5jtHo/s1600/clr_ParseDateTime.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="217" src="http://2.bp.blogspot.com/_OEOq9aEto20/TCY1T2420dI/AAAAAAAAEu4/5fs7s-5jtHo/s400/clr_ParseDateTime.png" width="400" /></a></div>
<p>Why would I want NULL on failure you might ask. Well, if I get a NULL back, then I can easily check against NULL for success and use functions such as COALESCE to&nbsp;substitute&nbsp;a default value if the parsing failed. A good case for us to use this is when we have blank strings that need to convert into a default date. CONVERT cannot cast the value '' to a datetime and thus throws an error.</p>
<p>Now I can do things like the following to allow processing to complete if CONVERT hits a bad value.
<div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/_OEOq9aEto20/TCY7cg2r9yI/AAAAAAAAEvA/niTYUMqD3GM/s1600/sql_ParseDateTime.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="318" src="http://2.bp.blogspot.com/_OEOq9aEto20/TCY7cg2r9yI/AAAAAAAAEvA/niTYUMqD3GM/s400/sql_ParseDateTime.png" width="400" /></a></div>
<p>Now the drawbacks of using this method. If you need to make sure you have all valid values beforehand, <b>this will cause those to fail silently</b>. An alternative would be to use this to check for invalid values. You can do something like this to find problematic values:
<div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_OEOq9aEto20/TCY89DUDzII/AAAAAAAAEvI/-4_qQpjXIB0/s1600/sql_ParseDateTime2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="332" src="http://4.bp.blogspot.com/_OEOq9aEto20/TCY89DUDzII/AAAAAAAAEvI/-4_qQpjXIB0/s400/sql_ParseDateTime2.png" width="400" /></a></div>
<p>This allows you to find all&nbsp;unconvertible&nbsp;values without SQL throwing an error as it would if you had tested with CONVERT(). We mainly use this function in the second situation. We want to know all values that would cause problems.</p>
<p>I have also made versions for Int, BigInt and Money following the same basic pattern. As with any CLR functions, make sure you know the security and performance&nbsp;implications&nbsp;when using it. Hopefully if you do a lot of data staging then converting this could make your life easier.</p>
</p></p></p></p>

  </div><a class="u-url" href="/.net/c%23/clr/sql/2010/06/26/using-nets-tryparse-in-sql-clr.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
